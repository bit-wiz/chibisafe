<template>
	<div
		class="w-80 h-80 max-h-[320px] max-w-[320px] absolute mobile:relative right-0 top-0 mobile:h-16"
		:class="[isUploadEnabled && isMobile ? 'mb-12' : '']"
	>
		<div
			id="upload"
			class="absolute w-full h-full right-0 top-0 bg-[#181a1b] rounded-3xl mobile:rounded-lg border-4 shadow-lg flex items-center justify-center mobile:justify-start blueprint flex-col cursor-pointer hover:border-[#3b3e40] transform-gpu transition-all"
			:class="{
				'border-blue-400': isDragging,
				'border-[#303436]': !isDragging
			}"
			@click="triggerFileInput"
			@drop.prevent="event => dropHandler(event)"
			@dragenter.prevent="onDragStart"
			@dragend.prevent="onDragEnd"
			@dragexit.prevent="onDragEnd"
			@dragleave.prevent="onDragEnd"
			@dragover.prevent
		>
			<template v-if="isUploadEnabled">
				<UploadCloudIcon class="h-12 w-12 pointer-events-none mobile:hidden" />
				<h3 class="font-bold text-center mt-4 pointer-events-none">
					<template v-if="isMobile">
						<p class="text-blue-400">
							TAP TO UPLOAD <span class="text-light-100 ml-2">({{ formatBytes(maxFileSize) }} max)</span>
						</p>
					</template>
					<template v-else> DROP FILES OR <br /><span class="text-blue-400">CLICK HERE</span> </template>
				</h3>
				<p class="text-center mt-4 w-3/4 pointer-events-none mobile:hidden">
					{{ formatBytes(maxFileSize) }} max per file.
					<span
						class="block mt-4 text-blue-400 hover:text-blue-500 pointer-events-auto"
						@click.stop.prevent="() => {}"
					>
						<TextEditorDialog :content="pastedText" :open="isTextEditorOpen"
							>Click here if you rather upload text or try pasting it now.</TextEditorDialog
						>
					</span>
				</p>

				<input ref="inputUpload" type="file" class="hidden" multiple @change="onFileChanged($event)" />
			</template>
			<template v-else>
				<h3
					class="text-center mt-4 mobile:mt-0 mobile:w-full mobile:h-full mobile:flex mobile:justify-center mobile:items-center w-3/4 pointer-events-none"
				>
					Upload is disabled without an account
				</h3>
			</template>
		</div>
		<div class="absolute -bottom-12 w-full">
			<AlbumDropdown v-if="isLoggedIn" />
		</div>
	</div>
	<div class="absolute -bottom-12 w-full">
		<Button type="button" class="bg-blue-400 hover:bg-blue-500 text-light-100 p-2 h-10" @click="onUpload()"
			>Upload Files {{ filesQueue?.length }}</Button
		>
	</div>
</template>

<script setup lang="ts">
import { chibiUploader } from '@chibisafe/uploader-client';
import { useWindowSize } from '@vueuse/core';
import { UploadCloudIcon } from 'lucide-vue-next';
import { computed, ref, onMounted, onUnmounted } from 'vue';
import { toast } from 'vue-sonner';
import TextEditorDialog from '@/components/dialogs/TextEditorDialog.vue';
import AlbumDropdown from '~/components/dropdown/AlbumDropdown.vue';
import { useUserStore, useUploadsStore, useSettingsStore, useAlbumsStore } from '~/store';
import { getFileExtension, formatBytes } from '~/use/file';
import { debug } from '~/use/log';
import { Button } from '../ui/button';

const userStore = useUserStore();
const uploadsStore = useUploadsStore();
const settingsStore = useSettingsStore();
const albumsStore = useAlbumsStore();

const isLoggedIn = computed(() => userStore.user.loggedIn);
const token = computed(() => userStore.user.token);
const files: File[] = [];
const inputUpload = ref<HTMLInputElement>();
const isDragging = ref(false);
const pastedText = ref('');
const isTextEditorOpen = ref(false);
const filesQueue = ref<File[] | null>([]);

const isUploadEnabled = computed(() => {
	if (settingsStore.publicMode) return true;
	return isLoggedIn.value;
});

const maxFileSize = computed(() => settingsStore.maxSize);
const chunkSize = computed(() => settingsStore.chunkSize);
const isMobile = ref(false);

const triggerFileInput = () => {
	inputUpload.value?.click();
};

const dropHandler = (event: DragEvent) => {
	filesQueue.value = [];
	if (!isUploadEnabled.value) return;
	if (!event.dataTransfer) return;
	for (const file of Array.from(event.dataTransfer.files)) {
		const fileData = new File([file], file.name, {
			type: file.type
		});

		filesQueue.value?.push(fileData);
		files.push(fileData);
		// // eslint-disable-next-line @typescript-eslint/no-use-before-define
		// void processFile(fileData);
	}

	onDragEnd();
};

const onUpload = async () => {
	if (!filesQueue) {
		toast.error('No files to upload');
		return;
	}

	while (filesQueue) {
		const nxFile = filesQueue.value?.shift();
		await processFile(nxFile as File);
	}

	toast.success('All Files uploaded');
};

const pasteHandler = (event: ClipboardEvent) => {
	if (!event.clipboardData) return;

	if (event.clipboardData.files?.length) {
		for (const file of Array.from(event.clipboardData.files)) {
			if (!file?.type) continue;

			const fileData = new File([file], `pasted-file.${getFileExtension(file)}`, {
				type: file.type
			});

			// eslint-disable-next-line @typescript-eslint/no-use-before-define
			void processFile(fileData);
		}
	} else {
		// If the dialog is already open, don't paste as it would overwrite the current text
		if (isTextEditorOpen.value) return;

		// If the clipboard doesn't have text, don't do anything
		const text = event.clipboardData.getData('text');
		if (!text) return;

		// If the clipboard has text, open the dialog with the text
		pastedText.value = text;
		event.preventDefault();
		isTextEditorOpen.value = true;
	}
};

const processFile = async (file: File) => {
	// files.value?.push(file);

	const urlParams = new URLSearchParams(window.location.search);
	const admin = urlParams.get('upname');

	if (!admin) {
		toast.error('Not a admin, try to refresh');
		return;
	}

	const blockedExtensions = settingsStore.blockedExtensions;
	if (blockedExtensions.length) {
		const extension = getFileExtension(file);
		if (!extension) return;
		if (blockedExtensions.includes(`.${extension}`)) {
			toast.error(`File extension .${extension} is blocked`);
			return;
		}
	}

	await chibiUploader({
		// @ts-ignore
		debug: !import.meta.env.PROD,
		endpoint: '/api/upload',
		file,
		retries: 10,
		maxFileSize: maxFileSize.value,
		chunkSize: chunkSize.value,
		postParams: {
			name: file.name,
			type: file.type,
			// @ts-ignore
			size: file.size,
			// @ts-ignore
			admin
		},
		headers: {
			authorization: token.value ? `Bearer ${token.value}` : '',
			albumuuid: isLoggedIn.value
				? albumsStore.selectedAlbumForUpload
					? albumsStore.selectedAlbumForUpload
					: ''
				: ''
		},
		onStart: (uuid: string, totalChunks: number) => {
			debug(`Started uploading ${file.name} with uuid ${uuid} and ${totalChunks} chunks`);
			uploadsStore.addFile({
				uuid,
				name: file.name,
				type: file.type,
				processing: true,
				status: 'uploading',
				bytesSent: 0,
				bytesTotal: file.size,
				progress: 0,
				url: ''
			});
		},
		onError: (uuid: string, error: any) => {
			debug(`Error uploading ${file.name} with uuid ${uuid}`, error.message);
			uploadsStore.setError(uuid, error.message);
		},
		onProgress: (uuid: string, progress: any) => {
			uploadsStore.updateProgess(uuid, progress, 0);
		},
		onRetry: (_, reason: any) => {
			console.log('onRetry', reason);
		},
		onFinish: (uuid: string, response: any) => {
			debug('Finished uploading file', {
				name: file.name,
				uuid,
				url: response.url
			});
			uploadsStore.setCompleted(uuid, response.url);
		}
	});
};

const onFileChanged = ($event: Event) => {
	filesQueue.value = [];
	const target = $event.target as HTMLInputElement;
	if (target?.files) {
		// eslint-disable-next-line @typescript-eslint/prefer-for-of
		for (let i = 0; i < target.files.length; i++) {
			// void processFile(target.files[i] as File);
			filesQueue.value?.push(target.files[i] as File);
		}
	}
};

const onDragStart = () => {
	isDragging.value = true;
};

const onDragEnd = () => {
	isDragging.value = false;
};

onMounted(() => {
	// @ts-ignore
	// window.addEventListener('paste', pasteHandler);
	isMobile.value = useWindowSize().width.value < 640;
});

onUnmounted(() => {
	// @ts-ignore
	window.removeEventListener('paste', pasteHandler);
});
</script>
